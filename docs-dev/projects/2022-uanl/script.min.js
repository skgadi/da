function syncSleepFor(t){for(var e=(new Date).getTime();(new Date).getTime()<e+t;);}const{createApp:createApp}=Vue,chartVar={data:[],series:{},root:null,chart:null,createSeries:function(t,e){let s=chartVar.chart.series.push(am5xy.SmoothedXLineSeries.new(chartVar.root,{name:t,xAxis:chartVar.xAxis,yAxis:chartVar.yAxis,valueYField:e,valueXField:"t",tooltip:am5.Tooltip.new(chartVar.root,{}),legendLabelText:"{name}",legendRangeLabelText:"{name}"}));s.strokes.template.set("strokeWidth",2),s.get("tooltip").label.set("text","[bold]{name}[/]\n{valueX.formatDate()}: {valueY}"),s.data.setAll(this.data),this.series[e]=s},makeRoot:function(){this.root=am5.Root.new("chartdiv")},init:function(){this.root.setThemes([am5themes_Animated.new(this.root)]),this.chart=this.root.container.children.push(am5xy.XYChart.new(this.root,{panY:!1,wheelY:"zoomX",layout:this.root.verticalLayout,maxTooltipDistance:0})),this.yAxis=this.chart.yAxes.push(am5xy.ValueAxis.new(this.root,{extraTooltipPrecision:1,renderer:am5xy.AxisRendererY.new(this.root,{})})),this.xAxis=this.chart.xAxes.push(am5xy.ValueAxis.new(this.root,{extraTooltipPrecision:1,renderer:am5xy.AxisRendererX.new(this.root,{})})),this.createSeries("Relay 1","S0"),this.createSeries("Relay 2","S1"),this.createSeries("Relay 3","S2"),this.createSeries("Relay 4","S3"),this.createSeries("Temperature setpoint","TR"),this.createSeries("Temperature","T"),this.createSeries("Resistance","R"),this.chart.set("cursor",am5xy.XYCursor.new(this.root,{behavior:"zoomXY",xAxis:this.xAxis})),this.xAxis.set("tooltip",am5.Tooltip.new(this.root,{themeTags:["axis"]})),this.yAxis.set("tooltip",am5.Tooltip.new(this.root,{themeTags:["axis"]})),this.legend=this.chart.children.push(am5.Legend.new(this.root,{})),this.legend.data.setAll(this.chart.series.values)},addDataPoint:function(t){let e,s=Object.keys(t);for(let t=0;t<s.length;t++)if("t"!=s[t]){e=s[t];break}this.series[e].data.push(t)},clear:function(){this.chart.dispose()},setVisibility:function(t,e){e?this.series[t].show():this.series[t].hide()}},leastCommonMultiple=(t,e)=>t*e/greatestCommonDivisor(t,e),greatestCommonDivisor=(t,e)=>{const s=t%e;return 0===s?e:greatestCommonDivisor(e,s)};let vueApp=createApp({data:()=>({status:{process:{isRunning:!1,hTimeInterval:null,t:0,tS:1,tSocketWait:50},comm:{text:"Communications",icon:"fa-fw fa-solid fa-angle-down",expand:!0},da:{text:"[Not connected]",icon:"fa-fw fa-regular fa-circle-xmark"},serial:{text:"[Not connected]",icon:"fa-fw fa-regular fa-circle-xmark"},visa:{text:"[Not connected]",icon:"fa-fw fa-regular fa-circle-xmark"}},ports:{serial:{selcted:null,list:[],baud:115200,tOut:.01},visa:{selcted:null,list:[]}},wSocket:{readyState:3},setValues:{voltage:100,temperature:100},relays:[[1],[1],[1],[1]],samplingTime:"",chart:chartVar,fileData:[]}),watch:{"ports.serial.selected":function(t,e){let s={type:"serial",command:"close"};s.port=e,this.sendDataToWSocket(s),this.status.serial={text:"[Not connected]",icon:"fa-fw fa-regular fa-circle-xmark"},s={},s.type="serial",s.command="open",s.port=t,s.baud=this.ports.serial.baud,s.tOut=this.ports.serial.tOut,this.sendDataToWSocket(s)},"ports.visa.selected":function(t,e){let s={type:"visa",command:"close"};s.resource=e,this.sendDataToWSocket(s),this.status.visa={text:"[Not connected]",icon:"fa-fw fa-regular fa-circle-xmark"},s={},s.type="visa",s.command="open",s.resource=t,this.sendDataToWSocket(s)}},computed:{relayTime:function(){try{let t=this.getRelayTime(0);for(let e=1;e<this.relays.length;e++)t=leastCommonMultiple(t,this.getRelayTime(e));return t}catch(t){return console.log("Error in relayTime"),console.log(t),-1}},samplingTimeInSec:function(){let t=30,e=1;try{let s=this.relays[0][0];for(let t=0;t<this.relays.length;t++)for(let e=0;e<this.relays[t].length;e++)s=greatestCommonDivisor(s,this.relays[t][e]);let a=math.evaluate(this.samplingTime);return a=Math.abs(Math.round(a)),isNaN(a)&&(a=t),(isNaN(s)||s<e)&&(s=e),[a,s]}catch(s){return console.log("Error in interpreting sampling time"),console.log(s),[t,e]}}},methods:{removeRelayTime:function(t){this.relays[t].length>1&&this.relays[t].pop()},getRelayTime:function(t){let e=0;for(let s=0;s<this.relays[t].length;s++)e+=this.relays[t][s];return e},connectIfNeeded:function(){this.wSocket.readyState>1&&(this.wSocket=new WebSocket("ws://localhost:8765"),this.wSocket.onmessage=(t=>{this.onReceiveCode(t.data)}),this.wSocket.onopen=(()=>{this.status.da={text:"[Connected]",icon:"fa-fw fa-solid fa-check"},this.requestPortsList()}),this.wSocket.onclose=(()=>{this.status.da={text:"[Not connected]",icon:"fa-fw fa-regular fa-circle-xmark"}}))},onReceiveCode:function(t){try{if(jsonData=JSON.parse(t),jsonData.data&&(jsonData.data=jsonData.data.replace(/(\r\n|\n|\r)/gm,"")),"string"==typeof jsonData.response&&(jsonData.response=jsonData.response.replace(/(\r\n|\n|\r)/gm,"")),!t.isError)if("serial"==jsonData.type){if("list"==jsonData.command&&(this.ports.serial.list=jsonData.response),"open"==jsonData.command&&this.ports.serial.selected==jsonData.port&&(this.status.serial={text:"[Connected]",icon:"fa-fw fa-solid fa-check"}),"sR"==jsonData.command){if("R:T"==jsonData.data){let t=parseFloat(jsonData.response);chartVar.addDataPoint({t:this.status.process.t,T:t})}if("R:R"==jsonData.data){let t=parseFloat(jsonData.response);chartVar.addDataPoint({t:this.status.process.t,TR:t})}if("R:S0"==jsonData.data){let t=parseFloat(jsonData.response);chartVar.addDataPoint({t:this.status.process.t,S0:t})}if("R:S1"==jsonData.data){let t=parseFloat(jsonData.response);chartVar.addDataPoint({t:this.status.process.t,S1:t})}if("R:S2"==jsonData.data){let t=parseFloat(jsonData.response);chartVar.addDataPoint({t:this.status.process.t,S2:t})}if("R:S3"==jsonData.data){let t=parseFloat(jsonData.response);chartVar.addDataPoint({t:this.status.process.t,S3:t})}}}else"visa"==jsonData.type&&("list"==jsonData.command&&(this.ports.visa.list=jsonData.response),"open"==jsonData.command&&this.ports.visa.selected==jsonData.resource&&(this.status.visa={text:"[Connected]",icon:"fa-fw fa-solid fa-check"}))}catch(t){console.log("Error in interpretting."),console.log(t)}},requestPortsList:function(){command={type:"serial",command:"list"},this.sendDataToWSocket(command),command={type:"visa",command:"list"},this.sendDataToWSocket(command)},sendDataToWSocket:function(t){try{1==this.wSocket.readyState&&this.wSocket.send(JSON.stringify(t))}catch(t){console.log("Error sendin command to Websocket"),console.log(t)}},requestData:function(){let t={type:"serial"};t.port=this.ports.serial.selected,t.baud=this.ports.serial.baud,t.tOut=this.ports.serial.tOut,t.command="sR",t.data="R:T\n",this.sendDataToWSocket(t),syncSleepFor(this.status.process.tSocketWait),t.data="R:R\n",this.sendDataToWSocket(t),syncSleepFor(this.status.process.tSocketWait),t.data="R:S0\n",this.sendDataToWSocket(t),syncSleepFor(this.status.process.tSocketWait),t.data="R:S1\n",this.sendDataToWSocket(t),syncSleepFor(this.status.process.tSocketWait),t.data="R:S2\n",this.sendDataToWSocket(t),syncSleepFor(this.status.process.tSocketWait),t.data="R:S3\n",this.sendDataToWSocket(t),this.status.process.t=this.status.process.t+this.status.process.tS},startStop:function(){this.status.process.isRunning?(clearInterval(this.status.process.hTimeInterval),this.status.process.isRunning=!1):confirm("Warning: you are about to start the process.\n\nIt will remove all the previous data.\n\n\nAre you sure?")&&(this.status.process.isRunning=!0,chartVar.clear(),chartVar.init(),this.status.process.t=0,this.status.process.tS=this.samplingTimeInSec[1],this.status.process.hTimeInterval=setInterval(()=>{vueApp.requestData()},1e3*this.status.process.tS))}},mounted:function(){chartVar.makeRoot(),chartVar.init()}}).mount("#app");setInterval(function(){vueApp.connectIfNeeded()},1e3);